pipeline {
    agent any

    environment {
        VENV_DIR = 'venv'
        metadataFile = 'metadata.yaml'
        pipe_DataLake = 'teste_DataLake'   // variável da pasta
        repository = 'https://github.com/Sara-Mirian-Santos/Pipeline_Python.git'
        appRepoBranch = 'main'
        gitHubCredentialsId = 'credencial_adm'
        // urlWebhook = 'https://webhookb2'
        folderBucket = 'bucket'
        artifact = 'artefato'
    }

    stages {
        stage('CheckoutAppRepo') {
            steps {
                script {
                    checkout([
                        $class: 'GitSCM',
                        userRemoteConfigs: [[
                            url: "${env.repository}",
                            credentialsId: "${env.gitHubCredentialsId}"
                        ]],
                        branches: [[name: "${env.appRepoBranch}"]]
                    ])
                }
            }
        }

        stage('MetadataValidation') {
            steps {
                script {
                    try {            
                        dir("${env.WORKSPACE}/${env.pipe_DataLake}") {     
                            // Verifica se o arquivo metadata.yaml existe
                            if (!fileExists(env.metadataFile)) {                  
                                def comment = "Arquivo `${env.metadataFile}` não encontrado. Adicione-o para continuar."
                                addGitLabMRComment(comment: comment)
                                error(comment)             
                            } else {
                                echo "Arquivo `${env.metadataFile}` encontrado. Verificando o conteúdo."            
                                // Carrega o conteúdo do metadata.yaml
                                def metadata = readYaml file: env.metadataFile            
                                // Verifica se todos os campos obrigatórios estão presentes
                                if (!metadata.artifact || !metadata.description || !metadata.version || !metadata.extensions || !metadata.nonProductiveConfigurationRepository) {                  
                                    def comment = "O arquivo `${env.metadataFile}` está incompleto. Os campos 'artifact', 'description', 'version', 'extensions' e 'nonProductiveConfigurationRepository' são obrigatórios."
                                    addGitLabMRComment(comment: comment)
                                    error(comment)              
                                } else {
                                    // Atualiza as variáveis de ambiente
                                    env.artifact = metadata.artifact
                                    env.description = metadata.description
                                    env.version = metadata.version
                                    env.extensions = metadata.extensions.join(',')
                                    env.nonProductiveConfigurationRepository = metadata.nonProductiveConfigurationRepository                  
                                    def comment = "Arquivo `${env.metadataFile}` validado:\n- artifact: ${env.artifact}\n- description: ${env.description}\n- version: ${env.version}\n- extensions: ${env.extensions}\n- nonProductiveConfigurationRepository: ${env.nonProductiveConfigurationRepository}."
                                    addGitLabMRComment(comment: comment)
                                    echo comment
                                }
                            }
                        }
                    } catch (Exception e) {            
                        def comment = "Erro ao verificar o arquivo `${env.metadataFile}`."
                        addGitLabMRComment(comment: "${comment} Verificar logs em ${BUILD_URL}console.")
                        error(comment)
                    }
                }            
            }
        }

        stage('Criar venv') {
            steps {
                script {
                    dir("${env.WORKSPACE}/${env.pipe_DataLake}") {
                        sh '''
                            python3 -m venv $VENV_DIR
                            ./venv/bin/pip install --upgrade pip
                        '''
                    }
                }
            }
        }
        stage('Instalar uv no venv') {
            steps {
                script {
                    dir("${env.WORKSPACE}/${env.pipe_DataLake}") {
                        sh '''
                            ./venv/bin/pip install uv
                            ./venv/bin/uv --version
                        '''
                    }
                }
            }
        }
        stage('Instalar dependências do projeto') {
            steps {
                script {
                    dir("${env.WORKSPACE}/${env.pipe_DataLake}") {
                        sh '''
                            ./venv/bin/uv sync
                            ./venv/bin/uv pip install .
                        '''
                    }
                }
            }
        }
        stage('Ruff (lint e format)') {
            steps {
                script {
                    dir("${env.WORKSPACE}/${env.pipe_DataLake}") {
                        sh '''
                            ./venv/bin/uv run ruff check
                            ./venv/bin/uv run ruff format --check
                        '''
                    }
                }
            }
        }
        stage('Rodar testes') {
            steps {
                script {
                    dir("${env.WORKSPACE}/${env.pipe_DataLake}") {
                        sh './venv/bin/uv run pytest'
                    }
                }
            }
        }
        stage('Empacotar artefato') {
            steps {
                script {
                    dir("${env.WORKSPACE}/${env.pipe_DataLake}") {
                        def extension = env.extensions.split(',')[0].trim()  //Usa a primeira extensão
                        def outputFile = "${env.artifact}_${env.version}.${extension}"
                        env.outputArtifact = outputFile
                        sh """
                            mkdir -p ${env.folderBucket}
                            python3 -m zipfile -c ${env.folderBucket}/${outputFile} \$(find . -name "*.py")
                            echo "Arquivo gerado em: ${env.folderBucket}/${outputFile}"
                        """
                    }
                }
            }
        }
        stage('Upload artefato para MinIO') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'minio-creds', usernameVariable: 'MINIO_USER', passwordVariable: 'MINIO_PASS')]) {
                    script {
                        dir("${env.WORKSPACE}/${env.pipe_DataLake}") {
                            sh """
                                mc alias set local http://localhost:9000 $MINIO_USER $MINIO_PASS
                                mc cp ${env.folderBucket}/${env.outputArtifact} local/dags-dev/
                                echo "Artefato enviado para MinIO: dags-dev/${env.outputArtifact}"
                            """
                        }
                    }
                }
            }
        }
    }
    post {
        always {
            cleanWs() // Limpa o workspace após a execução
        }
        failure {
            script {
                // office365ConnectorSend message: "Teste falhou ❌", webhookUrl: env.urlWebhook   
                echo "Erro na execução da esteira de teste."
            }
        }
        success {
            script {                
                // office365ConnectorSend message: "Teste finalizado com sucesso ✅", webhookUrl: env.urlWebhook
                echo "Esteira de teste executada com sucesso!"      
            }
        }
        aborted {
            // office365ConnectorSend message: "Teste abortado ⚠️", webhookUrl: env.urlWebhook
            updateGitlabCommitStatus name: 'CommitAndPushReportToGit', state: 'canceled'
        }
    }
}

